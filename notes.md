# Models

### Web3Store

Web3 store serves as easy access to account management within components.

##### Model

- **account** - references current account
- **web3** - object of current web3 provider
- **balance** - references balance of current account
- **network** - indicates current network
- **status** - oracle of truth for web3 context

##### Actions

- **setWeb3(_web3)** - constructor for web3 model
- **setAccount(_account)** - sets the account address and changes the status to LOADED
- **updateStatus(_status)** - manual changing of status behaviour. Enables reactive rendering from behaviour of web3 component. 
- **updateNetwork(_network)** - enables network to change reacting to component behaviour

##### Views

- **instance()** - returns web3 object
- **getBalanceEth()** - takes account balance in wei and represents it in eth = wei * 10^-18. Balance is wrapped in object to signify denomination.
- **getBalanceGwei()** - takes account balance in wei and represents it in gwei = wei * 10^-9. Balance is wrapped in object to signify denomination.
- **getBalanceWei()** - returns account balance. Balance is wrapped in object to signify denomination.


### ContractStore

The contract store is a means to reference multiple deployed contract objects. The "store" will contain a list of mappings of the deployed contract which has a key of its address location. It is intended that this can be programmatically generated by interpreting custom props from the web3Gate component in App.js similarly to the already present networks prop. The address/id will reference a seperate model "ContractInstance" which will serve as a single contract entity. The store will enable creation and deletion of these instances. Individual contracts will be modeled from within the ContractInstance model.

In order to utilise smart-contract functionality within an application, it is necessary to obtain:
  - the contract's abi (application binary interface, a json representation of the contract)
  - the contract's location address
  - web3 instance to interpret and execute functionality.

This can instantiate an instance of a smart contract as:
~~~
let new_contract_object = new web3.eth.Contract(contract.abi, contractAddress);
~~~
Utilising the web3 instance from the web3Store, functions of the contract instance can be accessed via contract.methods. The ./build from within the home directory of the application contains a contract.json file which contains data from which the application can exploit programmatically to enhance usability. 

The abi contains an array of all public facing contract information, as in constructors, public variables,functions and events. The relevant methods could be reconstructed elsewhere to enable more streamlined referencing for when they are needed for execution. Another possibility is to reconstruct the functions within the abi as action functions from within the model.
Also relevant from the contract.json file is a networks object which records the networks from which the smart contract has been deployed to as well as the transaction hash of the initial creation. This could enable refactoring of the hardcoded references in the networks prop.

The envisaged contract model state is to exclude smart-contract events to its own state-tree. Interaction between the trees may be necessary but achieving the core contract functionality takes precedence. 

The execution of functions can be "generally" seperated into two groups, getters and setters. In the instance of a getter function, the required function call to the blockchain is a simple asynchronous one-liner:

~~~
var read_variable = async contract.methods.getterFunction().call()
~~~

A setter is much more cumbersome involving multiple callback events which can be read more about [here](https://web3js.readthedocs.io/en/1.0/callbacks-promises-events.html#promievent). Essentially, it integrates event emitters for different stages of finality within a transaction call. 

~~~
web3.eth.sendTransaction({from: '0x123...', data: '0x432...'})
.once('transactionHash', function(hash){ ... })
.once('receipt', function(receipt){ ... })
.on('confirmation', function(confNumber, receipt){ ... })
.on('error', function(error){ ... })
.then(function(receipt){
    // will be fired once the receipt is mined
});
~~~

Resolving a state-tree system which can streamline this function execution will make application construction much easier.

##### Model

- **contracts** - object of objects mapping (contract_id -> contractInstance) 

##### Actions

- **add** - add an contract instance
- **remove** - remove a contract instance

##### Views

- **getAll** - return an easily interpretable representation of all loaded contracts from within the store


### Contract Instance

##### Model

- **address** - Location of contract
- **abi** - json representation of contract (types.frozen?)
- **contract** - web3 contract object
- **methods** - possible representation of contract methods (unsure)

##### Actions

(Difficult to define what is plausible for actionable functions for the model until more information is gathered. Being able to absract the callback promises event system into something more streamlined would be what is included here. Otherwise, the contract interface can be referenced in component rather in model)

##### Views

(Similar to above)
- **getMethods** - clear representation of methods object